
-- Combinators

k        = \ x y -> x
s x y z  = x z (y z)
i        = s k k 
app f s  = f s
comp f g = \ x -> f (g x)

-- Data types

data Bool where
  True :: Bool
  False :: Bool

data Nat where
  Zero :: Nat
  Suc :: Nat -> Nat

data List :: * -> * where
  Nil :: forall a. List a
  Cons :: forall a. a -> List a -> List a

data Vec :: Num -> * -> * where
  VNil :: forall a. Vec 0 a
  VCons :: forall (n :: Num) a . 0 <= n => a -> Vec n a -> Vec (n+1) a

data UNat :: Num -> * where
  UZero :: UNat 0
  USuc :: forall (n :: Num). UNat n -> UNat (n+1)


-- Vector kit

vhead :: forall (n :: Num) a. 0 <= n => Vec (n+1) a -> a
vhead (VCons x xs) = x

vtail :: forall (n :: Num) a. 0 <= n => Vec (n+1) a -> Vec n a
vtail (VCons x xs) = xs

vtail2 :: forall (n :: Num) a. 0 <= n, 0 <= (n + 1) => Vec (n+2) a -> Vec n a
vtail2 (VCons x (VCons y xs)) = xs

vtail3 :: forall (n :: Num) a. 1 <= n => Vec n a -> Vec (n-1) a
vtail3 (VCons x xs) = xs

vtail4 :: forall (n :: Num) a. 1 <= n => Vec n a -> Vec (n-1) a
vtail4 (VCons x xs) = xs

twotails :: forall (n :: Num) a. 0 <= n, 0 <= (n+1) => Vec (n+2) a -> Vec n a
twotails xs = vtail (vtail xs)

thing = comp vtail vhead

{-
vappend :: forall (m n :: Num) a . 0 <= m, 0 <= n => Vec m a -> Vec n a -> Vec (m+n) a
vappend VNil ys = ys
vappend (VCons x xs) ys = VCons x (vappend xs ys)

vrevapp :: forall (m n :: Num) a . Vec m a -> Vec n a -> Vec (m+n) a
vrevapp VNil ys = ys
vrevapp (VCons x xs) ys = vrevapp xs (VCons x ys)

vec :: forall (n :: Num) a. UNat n -> a -> Vec n a
vec UZero    a = VNil
vec (USuc m) a = VCons a (vec m a)
-}


one      = Suc Zero
two      = Suc one
three    = Suc two
v123     = VCons one (VCons two (VCons three VNil))
right    = vhead v123
righter  = app vtail v123



data Vec2 :: Num -> * -> * where
  VNil2   :: forall a (n :: Num) . n ~ 0 => Vec2 n a
  VCons2  :: forall a (n m :: Num) . 0 <= n, m ~ (n+1) => a -> Vec2 n a -> Vec2 m a

vid :: forall (n :: Num) a . Vec2 n a -> Vec2 n a
vid VNil2 = VNil2
-- vid (VCons2 x xs) = VCons2 x xs